package codegen

import (
	"fmt"
	"strings"

	"github.com/things-go/ens"
	"github.com/things-go/ens/utils"
)

func (g *CodeGen) GenAssist(modelPackage string) *CodeGen {
	packagePrefix := ""
	if p := pkgName(modelPackage); p != "" {
		packagePrefix = p + "."
	}
	if !g.disableDocComment {
		g.
			P("// Code generated by ", g.byName, ". DO NOT EDIT.").
			P("// version: ", g.version).
			P()
	}
	g.
		P("package ", g.packageName).
		P()

	//* import
	g.P("import (")
	if packagePrefix != "" {
		g.P(`"`, modelPackage, `"`, modelPackage)
		g.P()
	}
	g.P(`assist "github.com/things-go/gorm-assist"`)
	g.P(`"gorm.io/gorm"`)
	g.P(")")

	//* struct
	constFieldFn := func(stName, fieldName string) string {
		return fmt.Sprintf(`xx_%s_%s`, stName, fieldName)
	}
	constFieldWithTableNameFn := func(stName, fieldName string) string {
		return fmt.Sprintf(`xx_%[1]s_%[2]s_WithTableName`, stName, fieldName)
	}
	for _, et := range g.entities {
		structName := utils.CamelCase(et.Name)
		tableName := et.Name
		modelName := packagePrefix + structName

		constTableName := fmt.Sprintf("xx_%s_TableName", structName)
		{ //* const field
			g.P("const (")
			g.P("// hold model `", structName, "` table name")
			g.P(constTableName, ` = "`, tableName, `"`)
			g.P("// hold model `", structName, "` column name")
			for _, field := range et.Fields {
				fieldName := utils.CamelCase(field.Name)
				g.P(constFieldFn(structName, fieldName), ` = "`, field.Name, `"`)
			}
			g.P("// hold model `", structName, "` column name with table name(`", tableName, "`) prefix")
			for _, field := range et.Fields {
				fieldName := utils.CamelCase(field.Name)
				g.P(
					constFieldWithTableNameFn(structName, fieldName),
					" = ",
					constTableName, ` + "_" + `, constFieldFn(structName, fieldName),
				)
			}
			g.P(")")
			g.P()
		}

		varNativeModel := fmt.Sprintf(`xxx_%s_Native_Model`, structName)
		varModel := fmt.Sprintf(`xxx_%s_Model`, structName)
		fnInnerNew := fmt.Sprintf(`new_X_%s`, structName)
		{ //* var field
			g.
				P("var ", varNativeModel, " = ", fnInnerNew, `("")`).
				P("var ", varModel, " = ", fnInnerNew, "(", constTableName, ")").
				P()
		}
		typeActive := fmt.Sprintf("%s_Active", structName)
		//* type
		{
			g.P("type ", typeActive, " struct {")
			g.P("// private fields")
			g.P("xTableName string")
			g.P()
			g.P("ALL assist.Asterisk")
			for _, field := range et.Fields {
				fieldName := utils.CamelCase(field.Name)
				g.P(fieldName, ` assist.`, field.AssistDataType)
			}
			g.P("}")
			g.P()
		}
		//* function X_Native_xxx
		{
			g.
				P("// X_Native_", structName, " native model without TableName.").
				P("func X_Native_", structName, "() ", typeActive, " {").
				P("return ", varNativeModel).
				P("}").
				P()
		}
		//* function X_xxx
		{
			g.
				P("// X_", structName, " model with TableName `", tableName, "`.").
				P("func X_", structName, "() ", typeActive, " {").
				P("return ", varModel).
				P("}").
				P()
		}
		//* function new_X_xxx
		{
			g.
				P("func ", fnInnerNew, "(xTableName string) ", typeActive, " {").
				P("return ", typeActive, " {").
				P("xTableName: xTableName,").
				P().
				P("ALL:  assist.NewAsterisk(xTableName),").
				P()
			for _, field := range et.Fields {
				fieldName := utils.CamelCase(field.Name)
				g.P(fieldName, ": assist.New", field.AssistDataType, "(xTableName, ", constFieldFn(structName, fieldName), "),")
			}
			g.
				P("}").
				P("}").
				P()
		}
		//* function New_X_xxxx
		{
			g.
				P("// New_X_", structName, " new instance.").
				P("func New_X_", structName, "(xTableName string) ", typeActive, " {").
				P("switch xTableName {").
				P(`case "":`).
				P("return ", varNativeModel).
				P("case ", constTableName, ":").
				P("return ", varModel).
				P("default:").
				P("return ", fnInnerNew, "(xTableName)").
				P("}").
				P("}").
				P()
		}
		//* method As
		{
			g.
				P("// As alias").
				P("func (*", typeActive, ") As(alias string) ", typeActive, " {").
				P("return New_X_", structName, "(alias)").
				P("}").
				P()
		}
		//* method X_TableName
		{
			g.
				P("// X_TableName hold table name when call New_X_", structName, " or ", structName, "_Active.As that you defined.").
				P("func (x *", typeActive, ") X_TableName() string {").
				P("return x.xTableName").
				P("}").
				P()
		}

		//* method X_Model
		{
			g.
				P("// X_Model model").
				P("func (*", typeActive, ") X_Model() *", modelName, " {").
				P("return &", modelName, "{}").
				P("}").
				P()
		}
		//* method X_Executor
		{
			g.
				P("// X_Executor new entity executor which suggest use only once.").
				P("func (*", typeActive, ") X_Executor(db *gorm.DB) *assist.Executor[", modelName, "]  {").
				P("return assist.NewExecutor[", modelName, "](db)").
				P("}").
				P()
		}
		//* method X_SelectExpr
		{
			g.
				P("// X_SelectExpr select model fields").
				P("func (x *", typeActive, ") X_SelectExpr() []assist.Expr {").
				P("return []assist.Expr{")
			for _, field := range et.Fields {
				g.P("x.", utils.CamelCase(field.Name), ",")
			}
			g.
				P("}").
				P("}").
				P()
		}

		//* method X_Variant_SelectExpr
		{
			g.
				P("// X_Variant_SelectExpr select model fields, but time.Time field convert to timestamp(int64).").
				P("func (x *", typeActive, ") X_Variant_SelectExpr(prefixes ...string) []assist.Expr {").
				P("if len(prefixes) > 0 {").
				P("return []assist.Expr{")
			for _, field := range et.Fields {
				g.P(genAssist_Variant_SelectExpr(structName, field, true))
			}
			g.
				P("}").
				P("} else {").
				P("return []assist.Expr{")
			for _, field := range et.Fields {
				g.P(genAssist_Variant_SelectExpr(structName, field, false))
			}
			g.
				P("}").
				P("}").
				P("}").
				P()
		}

		// table and column field
		{
			//* method TableName
			g.P("// TableName hold model `", structName, "` table name returns `", tableName, "`.").
				P("func (*", typeActive, ") TableName() string {").
				P("return ", constTableName).
				P("}").
				P()

			for _, field := range et.Fields {
				fieldName := utils.CamelCase(field.Name)
				columnName := field.Name
				//* method Field_xxx
				g.
					P("// Field_", fieldName, " hold model `", structName, "` column name.").
					P("// if prefixes not exist returns `", columnName, "`, others `{prefixes[0]}_", columnName, "`").
					P("func (*", typeActive, ") Field_", fieldName, "(prefixes ...string) string {").
					P("if len(prefixes) == 0 {").
					P("return ", constFieldFn(structName, fieldName)).
					P("}").
					P("if prefixes[0] == ", constTableName, " {").
					P("return ", constFieldWithTableNameFn(structName, fieldName)).
					P("}").
					P(`return prefixes[0] + "_" + `, constFieldFn(structName, fieldName)).
					P("}").
					P()
			}
		}
	}
	return g
}

// pkgName returns the package name from a Go
// identifier with a package qualifier.
func pkgName(p string) string {
	if p == "" {
		return ""
	}
	i := strings.LastIndexByte(p, '/')
	if i == -1 {
		return p
	}
	return p[i+1:]
}

func genAssist_Variant_SelectExpr(structName string, field *ens.FieldDescriptor, hasPrefix bool) string {
	fieldName := utils.CamelCase(field.Name)

	b := strings.Builder{}
	b.Grow(64)
	b.WriteString("x.")
	b.WriteString(fieldName)
	if field.Type.IsTime() {
		b.WriteString(".UnixTimestamp()")
		if field.Nullable {
			b.WriteString(".IfNull(0)")
		}
		if !hasPrefix {
			b.WriteString(".As(")
			b.WriteString(fmt.Sprintf(`xx_%s_%s`, structName, fieldName))
			b.WriteString(")")
		}
	}
	if hasPrefix {
		b.WriteString(".As(x.Field_")
		b.WriteString(fieldName)
		b.WriteString("(prefixes...))")
	}
	b.WriteString(",")
	return b.String()
}
