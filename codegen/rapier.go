package codegen

import (
	"fmt"
	"strings"

	"github.com/things-go/ens"
	"github.com/things-go/ens/utils"
)

func (g *CodeGen) GenRapier(modelImportPath string) *CodeGen {
	pkgQualifierPrefix := ""
	if p := utils.PkgName(modelImportPath); p != "" {
		pkgQualifierPrefix = p + "."
	}
	if !g.disableDocComment {
		g.Printf("// Code generated by %s. DO NOT EDIT.\n", g.byName)
		g.Printf("// version: %s\n", g.version)
		g.Println()
	}
	g.Printf("package %s\n", g.packageName)
	g.Println()

	//* import
	g.Println("import (")
	if pkgQualifierPrefix != "" {
		g.Printf("\"%s\"\n", modelImportPath)
		g.Println()
	}
	g.Println(`rapier "github.com/thinkgos/gorm-rapier"`)
	g.Println(`"gorm.io/gorm"`)
	g.Println(")")

	//* struct
	for _, et := range g.entities {
		structName := utils.CamelCase(et.Name)
		tableName := et.Name

		varRefNative := fmt.Sprintf(`ref_%s_Native`, structName)
		funcInnerNew := fmt.Sprintf(`new_%s`, structName)
		{ //* var field
			g.Printf("var %s = New_%s(\"%s\")\n", varRefNative, structName, tableName)
			g.Println()
		}

		typeNative := fmt.Sprintf("%s_Native", structName)
		//* type
		{
			g.Printf("type %s struct {\n", typeNative)
			g.Println("refAlias string")
			g.Println("refTableName string")
			g.Println("ALL rapier.Asterisk")
			for _, field := range et.Fields {
				g.Printf("%s rapier.%s\n", utils.CamelCase(field.Name), field.RapierDataType)
			}
			g.Println("}")
			g.Println()
		}
		//* function new_xxx
		{
			g.Printf("func %s(tableName, alias string) *%s {\n", funcInnerNew, typeNative)
			g.Printf("return &%s {\n", typeNative)
			g.Println("refAlias: alias,")
			g.Println("refTableName: tableName,")
			g.Println("ALL:  rapier.NewAsterisk(alias),")
			for _, field := range et.Fields {
				fieldName := utils.CamelCase(field.Name)
				g.Printf("%s: rapier.New%s(alias, \"%s\"),\n", fieldName, field.RapierDataType, field.Name)
			}
			g.Println("}")
			g.Println("}")
			g.Println()
		}
		//* function Ref_xxx
		{
			g.Printf("// Ref_%s model with TableName `%s`.\n", structName, tableName)
			g.Println("// NOTE: Don't modify any public field!!!")
			g.Printf("func Ref_%s() *%s {\n", structName, typeNative)
			g.Printf("return %s\n", varRefNative)
			g.Println("}")
			g.Println()
		}
		//* function New_xxxx
		{
			g.Printf("// New_%s new instance.\n", structName)
			g.Println("// NOTE: Don't modify any public field!!!")
			g.Printf("func New_%s(tableName string) *%s {\n", structName, typeNative)
			g.Printf("return %s(tableName, tableName)\n", funcInnerNew)
			g.Println("}")
			g.Println()
		}
		//* method As
		{
			g.Println("// As alias")
			g.Printf("func (x *%[1]s) As(alias string) *%[1]s {\n", typeNative)
			g.Printf("return %s(x.refTableName, alias)\n", funcInnerNew)
			g.Println("}")
			g.Println()
		}
		//* method Ref_Alias
		{
			g.Printf("// Ref_Alias hold alias name when call %[1]s_Native.As that you defined.\n", structName)
			g.Printf("func (x *%s) Ref_Alias() string {\n", typeNative)
			g.Println("return x.refAlias")
			g.Println("}")
			g.Println()
		}
		// impl TableName interface
		{
			//* method TableName
			g.Printf("// TableName hold table name when call New_%[1]s that you defined.\n", structName)
			g.Printf("func (x *%s) TableName() string {\n", typeNative)
			g.Println("return x.refTableName")
			g.Println("}")
			g.Println()
		}

		//* method New_Executor
		{
			modelName := pkgQualifierPrefix + structName
			g.Println("// New_Executor new entity executor which suggest use only once.")
			g.Printf("func (*%s) New_Executor(db *gorm.DB) *rapier.Executor[%s] {\n", typeNative, modelName)
			g.Printf("return rapier.NewExecutor[%s](db)\n", modelName)
			g.Println("}")
			g.Println()
		}
		//* method Select_Expr
		{
			g.Println("// Select_Expr select model fields")
			g.Printf("func (x *%s) Select_Expr() []rapier.Expr {\n", typeNative)
			g.Println("return []rapier.Expr{")
			for _, field := range et.Fields {
				g.Printf("x.%s,\n", utils.CamelCase(field.Name))
			}
			g.Println("}")
			g.Println("}")
			g.Println()
		}

		//* method Select_VariantExpr
		{
			g.Println("// Select_VariantExpr select model fields, but time.Time field convert to timestamp(int64).")
			g.Printf("func (x *%s) Select_VariantExpr(prefixes ...string) []rapier.Expr {\n", typeNative)
			g.Println("if len(prefixes) > 0 && prefixes[0] != \"\" {")
			g.Println("return []rapier.Expr{")
			for _, field := range et.Fields {
				g.Println(genRapier_SelectVariantExprField(structName, field, true))
			}
			g.Println("}")
			g.Println("} else {")
			g.Println("return []rapier.Expr{")
			for _, field := range et.Fields {
				g.Println(genRapier_SelectVariantExprField(structName, field, false))
			}
			g.Println("}")
			g.Println("}")
			g.Println("}")
			g.Println()
		}
	}
	return g
}

func genRapier_SelectVariantExprField(structName string, field *ens.FieldDescriptor, hasPrefix bool) string {
	fieldName := utils.CamelCase(field.Name)

	b := &strings.Builder{}
	b.Grow(64)
	b.WriteString("x.")
	b.WriteString(fieldName)
	if field.Type.IsTime() {
		b.WriteString(".UnixTimestamp()")
		if field.Nullable {
			b.WriteString(".IfNull(0)")
		}
		if !hasPrefix {
			fmt.Fprintf(b, ".As(x.%s.ColumnName())", fieldName)
		}
	}
	if hasPrefix {
		fmt.Fprintf(b, ".As(x.%s.FieldName(prefixes...))", fieldName)
	}
	b.WriteString(",")
	return b.String()
}
