package rapier

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/things-go/ens/utils"
	"golang.org/x/tools/imports"
)

var mustEscapeNames = []string{"TableName", "As", "Alias"}

type CodeGen struct {
	buf               bytes.Buffer
	EscapeName        map[string]struct{} // 转义名称, 需要转换的前面加X, 如果加X后与字段重复, 再追加直接不重复
	Entities          []*Struct           // required
	ByName            string              // required, 生成名称
	Version           string              // required, 生成版本
	PackageName       string              // required, go包名
	ModelImportPath   string              // required, model导入路径
	DisableDocComment bool                // 禁用doc注释
	EnableInt         bool                // 使能int8,uint8,int16,uint16,int32,uint32输出为int,uint
	EnableBoolInt     bool                // 使能bool输出int
}

// Bytes returns the CodeBuf's buffer.
func (g *CodeGen) Bytes() []byte {
	return g.buf.Bytes()
}

// FormatSource return formats and adjusts imports contents of the CodeGen's buffer.
func (g *CodeGen) FormatSource() ([]byte, error) {
	data := g.buf.Bytes()
	if len(data) == 0 {
		return data, nil
	}
	// return format.Source(data)
	// 格式化时, 如果需要插入或删除包是非常耗时的
	return imports.Process("", data, &imports.Options{
		Fragment:   false,
		AllErrors:  false,
		Comments:   true,
		TabIndent:  true,
		TabWidth:   4,
		FormatOnly: false,
	})
}

// Write appends the contents of p to the buffer,
func (g *CodeGen) Write(b []byte) (n int, err error) {
	return g.buf.Write(b)
}

// Print formats using the default formats for its operands and writes to the generated output.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
func (g *CodeGen) Print(a ...any) (n int, err error) {
	return fmt.Fprint(&g.buf, a...)
}

// Printf formats according to a format specifier for its operands and writes to the generated output.
// It returns the number of bytes written and any write error encountered.
func (g *CodeGen) Printf(format string, a ...any) (n int, err error) {
	return fmt.Fprintf(&g.buf, format, a...)
}

// Fprintln formats using the default formats to the generated output.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
func (g *CodeGen) Println(a ...any) (n int, err error) {
	return fmt.Fprintln(&g.buf, a...)
}

func (g *CodeGen) Gen() *CodeGen {
	pkgQualifierPrefix := ""
	if p := utils.PkgName(g.ModelImportPath); p != "" {
		pkgQualifierPrefix = p + "."
	}
	if !g.DisableDocComment {
		g.Printf("// Code generated by %s. DO NOT EDIT.\n", g.ByName) // nolint: errcheck
		g.Printf("// version: %s\n", g.Version)                       // nolint: errcheck
		g.Println()                                                   // nolint: errcheck
	}
	g.Printf("package %s\n", g.PackageName) // nolint: errcheck
	g.Println()                             // nolint: errcheck

	//* import
	g.Println("import (") // nolint: errcheck
	if pkgQualifierPrefix != "" {
		g.Printf("\"%s\"\n", g.ModelImportPath) // nolint: errcheck
		g.Println()                             // nolint: errcheck
	}
	g.Println(`rapier "github.com/thinkgos/gorm-rapier"`) // nolint: errcheck
	g.Println(`"gorm.io/gorm"`)                           // nolint: errcheck
	g.Println(")")                                        // nolint: errcheck

	//* struct
	for _, et := range g.Entities {
		g.escapeStructFields(et)
		structGoName := et.GoName
		tableName := et.TableName

		varRefNative := fmt.Sprintf(`ref_%s_Native`, structGoName)
		funcInnerNew := fmt.Sprintf(`new_%s`, structGoName)
		{ //* var field
			g.Printf("var %s = New_%s(\"%s\")\n", varRefNative, structGoName, tableName) // nolint: errcheck
			g.Println()                                                                  // nolint: errcheck
		}

		typeNative := fmt.Sprintf("%s_Native", structGoName)
		//* type
		{
			g.Printf("type %s struct {\n", typeNative) // nolint: errcheck
			g.Println("refAlias string")               // nolint: errcheck
			g.Println("refTableName string")           // nolint: errcheck
			g.Println("ALL rapier.Asterisk")           // nolint: errcheck
			for _, field := range et.Fields {
				comment := ""
				if field.Comment != "" {
					comment = "// " + field.Comment
				}
				g.Printf("%s rapier.%s %s\n", field.GoName, g.intoTypeName(field.Type), comment) // nolint: errcheck
			}
			g.Println("}") // nolint: errcheck
			g.Println()    // nolint: errcheck
		}
		//* function new_xxx
		{
			g.Printf("func %s(tableName, alias string) *%s {\n", funcInnerNew, typeNative) // nolint: errcheck
			g.Printf("return &%s {\n", typeNative)                                         // nolint: errcheck
			g.Println("refAlias: alias,")                                                  // nolint: errcheck
			g.Println("refTableName: tableName,")                                          // nolint: errcheck
			g.Println("ALL:  rapier.NewAsterisk(alias),")                                  // nolint: errcheck
			for _, field := range et.Fields {
				g.Printf("%s: rapier.New%s(alias, \"%s\"),\n", field.GoName, g.intoTypeName(field.Type), field.ColumnName) // nolint: errcheck
			}
			g.Println("}") // nolint: errcheck
			g.Println("}") // nolint: errcheck
			g.Println()    // nolint: errcheck
		}
		//* function Ref_xxx
		{
			g.Printf("// Ref_%s model with TableName `%s`.\n", structGoName, tableName) // nolint: errcheck
			g.Println("// NOTE: Don't modify any public field!!!")                      // nolint: errcheck
			g.Printf("func Ref_%s() *%s {\n", structGoName, typeNative)                 // nolint: errcheck
			g.Printf("return %s\n", varRefNative)                                       // nolint: errcheck
			g.Println("}")                                                              // nolint: errcheck
			g.Println()                                                                 // nolint: errcheck
		}
		//* function New_xxxx
		{
			g.Printf("// New_%s new instance.\n", structGoName)                         // nolint: errcheck
			g.Println("// NOTE: Don't modify any public field!!!")                      // nolint: errcheck
			g.Printf("func New_%s(tableName string) *%s {\n", structGoName, typeNative) // nolint: errcheck
			g.Printf("return %s(tableName, tableName)\n", funcInnerNew)                 // nolint: errcheck
			g.Println("}")                                                              // nolint: errcheck
			g.Println()                                                                 // nolint: errcheck
		}
		//* method As
		{
			g.Println("// As alias")                                            // nolint: errcheck
			g.Printf("func (x *%[1]s) As(alias string) *%[1]s {\n", typeNative) // nolint: errcheck
			g.Printf("return %s(x.refTableName, alias)\n", funcInnerNew)        // nolint: errcheck
			g.Println("}")                                                      // nolint: errcheck
			g.Println()                                                         // nolint: errcheck
		}
		//* method Alias
		{
			g.Printf("// Alias hold alias name when call %[1]s_Native.As that you defined.\n", structGoName) // nolint: errcheck
			g.Printf("func (x *%s) Alias() string {\n", typeNative)                                          // nolint: errcheck
			g.Println("return x.refAlias")                                                                   // nolint: errcheck
			g.Println("}")                                                                                   // nolint: errcheck
			g.Println()                                                                                      // nolint: errcheck
		}
		// impl TableName interface
		{
			//* method TableName
			g.Printf("// TableName hold table name when call New_%[1]s that you defined.\n", structGoName) // nolint: errcheck
			g.Printf("func (x *%s) TableName() string {\n", typeNative)                                    // nolint: errcheck
			g.Println("return x.refTableName")                                                             // nolint: errcheck
			g.Println("}")                                                                                 // nolint: errcheck
			g.Println()                                                                                    // nolint: errcheck
		}

		//* method New_Executor
		{
			modelName := pkgQualifierPrefix + structGoName
			g.Println("// New_Executor new entity executor which suggest use only once.")                    // nolint: errcheck
			g.Printf("func (*%s) New_Executor(db *gorm.DB) *rapier.Executor[%s] {\n", typeNative, modelName) // nolint: errcheck
			g.Printf("return rapier.NewExecutor[%s](db)\n", modelName)                                       // nolint: errcheck
			g.Println("}")                                                                                   // nolint: errcheck
			g.Println()                                                                                      // nolint: errcheck
		}
		//* method Select_Expr
		{
			g.Println("// Select_Expr select model fields")                      // nolint: errcheck
			g.Printf("func (x *%s) Select_Expr() []rapier.Expr {\n", typeNative) // nolint: errcheck
			g.Println("return []rapier.Expr{")                                   // nolint: errcheck
			for _, field := range et.Fields {
				g.Printf("x.%s,\n", field.GoName) // nolint: errcheck
			}
			g.Println("}") // nolint: errcheck
			g.Println("}") // nolint: errcheck
			g.Println()    // nolint: errcheck
		}

		//* method Select_VariantExpr
		{
			g.Println("// Select_VariantExpr select model fields, but time.Time field convert to timestamp(int64).") // nolint: errcheck
			g.Printf("func (x *%s) Select_VariantExpr(prefixes ...string) []rapier.Expr {\n", typeNative)            // nolint: errcheck
			g.Println("if len(prefixes) > 0 && prefixes[0] != \"\" {")                                               // nolint: errcheck
			g.Println("return []rapier.Expr{")                                                                       // nolint: errcheck
			for _, field := range et.Fields {
				g.Println(genRapier_SelectVariantExprField(field, true)) // nolint: errcheck
			}
			g.Println("}")                     // nolint: errcheck
			g.Println("} else {")              // nolint: errcheck
			g.Println("return []rapier.Expr{") // nolint: errcheck
			for _, field := range et.Fields {
				g.Println(genRapier_SelectVariantExprField(field, false)) // nolint: errcheck
			}
			g.Println("}") // nolint: errcheck
			g.Println("}") // nolint: errcheck
			g.Println("}") // nolint: errcheck
			g.Println()    // nolint: errcheck
		}
	}
	return g
}

func (g *CodeGen) escapeStructFields(et *Struct) {
	escapeNames := make(map[string]struct{})
	for _, v := range mustEscapeNames {
		escapeNames[v] = struct{}{}
	}
	for k := range g.EscapeName {
		escapeNames[k] = struct{}{}
	}
	existFieldName := make(map[string]struct{}, len(et.Fields))
	for _, field := range et.Fields {
		existFieldName[field.GoName] = struct{}{}
	}
	// escape
	for _, field := range et.Fields {
		goName := field.GoName
		for {
			_, ok := escapeNames[goName]
			if !ok { // need to escape
				break
			}
			goName = "X" + goName
			// 和当前字段存在的重复, 再追加一个
			_, ok = existFieldName[goName]
			if ok {
				goName = "X" + goName
			}
		}
		if field.GoName != goName {
			field.GoName = goName
			escapeNames[goName] = struct{}{} // 添加为必须转义
		}
	}
}

func (g *CodeGen) intoTypeName(t Type) string {
	if g.EnableInt {
		switch t { // nolint: exhaustive
		case Int8, Int16, Int32:
			return Int.String()
		case Uint8, Uint16, Uint32:
			return Uint.String()
		}
	}
	if g.EnableBoolInt && t == Bool {
		return Int.String()
	}
	return t.String()
}

func genRapier_SelectVariantExprField(field *StructField, hasPrefix bool) string {
	goName := field.GoName

	b := &strings.Builder{}
	b.Grow(64)
	b.WriteString("x.")
	b.WriteString(goName)
	if field.Type == Time {
		b.WriteString(".UnixTimestamp()")
		if field.Nullable {
			b.WriteString(".IfNull(0)")
		}
		if !hasPrefix {
			fmt.Fprintf(b, ".As(x.%s.ColumnName())", goName)
		}
	}
	if hasPrefix {
		fmt.Fprintf(b, ".As(x.%s.FieldName(prefixes...))", goName)
	}
	b.WriteString(",")
	return b.String()
}
